# ClipSafe DL

Телеграм-бот для без потерь операций с видео: ремукс, lossless-обрезка, извлечение аудио и превью. Репозиторий содержит каркас, на базе которого можно быстро развить полноценный сервис «ClipSafe DL».

## Цели и принципы
- По умолчанию сохраняем исходные потоки (`-c copy`) и делаем только ремукс.
- Перекодирование разрешено только по явному запросу пользователя.
- Поддерживаем загрузку файлов в чат и прямые ссылки с `Content-Length`/`Accept-Ranges`.
- Для YouTube/TikTok и других ограниченных платформ выполняем только показ метаданных/превью без скачивания.

## Пользовательские сценарии
- **Файл в чат:** бот принимает документ/видео, проверяет лимиты, предлагает кнопки операций: «Оставить оригинал», «Ремукс», «Вырезать», «Аудио», «Превью».
- **Прямая ссылка:** выполняется HEAD-запрос, валидация домена, лимитов размера и диапазонов. Далее сценарий идентичен загрузке файла.
- **YouTube/TikTok:** бот возвращает заготовленный текст отказа и (в будущем) карточку с превью/субтитрами, не скачивая контент.

## Команды и меню
- `/start` — приветствие и обзор возможностей.
- `/help` — краткая справка об операциях и ограничениях.
- `/upload` — подсказка по форматам и лимитам загрузки.
- `/link` — инструкция по работе с прямыми ссылками.
- `/trim` — запрос меток начала/конца (точное и быстрое обрезание по ключевым кадрам).
- `/format` — выбор контейнера (MP4/MKV) с предупреждением о совместимости.
- `/queue` — последние задачи пользователя (статус, время создания).
- `/cancel` — отмена последней отложенной задачи.

Кнопки в интерфейсе: «Ремукс», «Вырезать», «Аудио», «Превью», «Оставить оригинал». Каркас формирует инлайн-клавиатуру в `app/bot.py`.

## Архитектура (Python стек)
```
app/
  __init__.py
  __main__.py        # точка входа бота (long polling)
  bot.py             # хендлеры aiogram, FSM в перспективе
  commands.py        # установка /setmycommands
  config.py          # загрузка CLIPSAFE_* переменных окружения
  ffmpeg_ops.py      # генераторы команд ffmpeg и helper run_ffmpeg
  jobs.py            # Redis-очередь, черновики, статусы задач
  models.py          # типы задач, dataclass Job, перечисления
  storage.py         # выделение временных/результирующих путей
  texts.py           # шаблоны сообщений и статических ответов
  validators.py      # валидация URL, парсинг таймкодов
  worker.py          # асинхронный воркер (заглушка для FFmpeg)
alembic/             # место для миграций БД (пусто)
Dockerfile
compose.yaml
pyproject.toml
.env.example
README.md
```

Основные сервисы в `compose.yaml`: бот, воркер, Redis. В Dockerfile уже установлен FFmpeg.

## Очередь задач
- Черновые задачи (до выбора операции) хранятся в Redis (`user:{id}:drafts`).
- После выбора операции задача переводится в статус `queued` и попадает в основной список `clipsafe:queue`.
- `JobQueue` позволяет отменять черновики (`/cancel`) и просматривать историю (`/queue`).
- Статусы (`draft → queued → processing → completed|failed|cancelled`) описаны в `app/models.py`.

## Лимиты и безопасность
- Переменные окружения `CLIPSAFE_MAX_FILE_GB`, `CLIPSAFE_MAX_DURATION_H`, `CLIPSAFE_JOBS_PER_HOUR`, списки доменов и т.д. задаются через `.env` (см. `.env.example`).
- `validators.ensure_allowed_url` проверяет схему, домен (whitelist), приватные IP, заголовки `Content-Type/Length/Accept-Ranges`. При несоответствии возвращает текст ошибки.
- Для платформ YouTube/TikTok используется предустановленный отказ `texts.YTDL_REFUSAL_MESSAGE`.
- TODO: интеграция с антивирусом (ClamAV), подтверждение прав на контент, автоудаление файлов по TTL.

## FFmpeg операции
`app/ffmpeg_ops.py` содержит генераторы команд для:
- Ремукса в MP4/MKV с `-map 0 -c copy -movflags +faststart`.
- Lossless-обрезки (`-ss/-to` + `-c copy` или «смарт» вариант `-c:v copy -c:a copy`).
- Извлечения аудио (`-vn -c:a copy`).
- Генерации превью-кадров (по таймкоду или номеру кадра).

Запуск ffmpeg вынесен в `run_ffmpeg`, возвращающий stdout/stderr и код выхода. В воркере сейчас стоит заглушка `NotImplementedError` — место, где нужно реализовать работу с временными файлами и запуск команд.

## Схема данных (минимальная)
```
users(id, username, is_premium, created_at)
jobs(id, user_id, type, status, src_kind, src_url, src_file_id,
     params jsonb, result_path, error, created_at, updated_at, ttl_at)
files(id, job_id, path, size, mime, hash, created_at)
```
В текущем каркасе события хранятся в Redis, но таблицы заданы для перспективной PostgreSQL-интеграции.

## Быстрый запуск
1. Создайте виртуальное окружение и установите зависимости:  
   `python -m venv .venv && .venv\\Scripts\\activate && pip install -e .`
2. Заполните `.env` на основе `.env.example` (токен, лимиты, домены).
3. Запустите Redis (`docker run --rm -p 6379:6379 redis:7`).
4. Запустите бота: `python -m app`.
5. Запустите воркер: `python -m app.worker` (пока выполняет заглушку, но обрабатывает статусы).

Docker-вариант: `docker compose up --build`.

## Тесты и контроль качества
- Юнит-тесты: парсинг таймкодов (`validators.parse_timecode`), валидация URL, выбор контейнера.
- Интеграционные: end-to-end ремукс, обрезка, извлечение аудио на наборе кодеков (пока TODO).
- Нагрузочные: большие файлы, параллельные задания, обрывы.

## План доработок
- Реализовать скачивание входных файлов (Telegram API / direct URL) во временную папку и полный цикл FFmpeg в `worker.py`.
- Добавить хранение результатов (локально/Nginx/S3) и выдачу ссылок, соблюдая TTL.
- Настроить авторское подтверждение контента и антиспам (N задач в час).
- Интегрировать Prometheus-метрики и структурированные логи.
- Подготовить миграции БД и модели ORM (SQLAlchemy/Pydantic) при необходимости.